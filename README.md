# ðŸš€ 15-30 Days DSA Roadmap to Crack â‚¹10â€“15 LPA Offers 
**[Complete PDF Downloads]()**.

### (Core Topics for Quick Mastery + Optional Advanced Concepts for Long-Term Dream Companies Preparation)

This roadmap helps you crack â‚¹10â€“15 LPA roles efficiently in 15-30 days by focusing on high-impact core DSA topics.
For those aiming higher and with more time, Tier 4 covers advanced data structures and algorithms for cracking top-tier dream companies â€” which may take 3-4 months to master.

---

## Time Complexity Primer 
### Before jumping into Tier 1, understand the Big-O complexities of key operations. Most interviews expect you to:
- Know the worst-case time complexity of standard algorithms
- Choose optimal solutions (avoid O(nÂ²) when O(n log n) is possible)
- Understand space-time tradeoffs (e.g., using extra space for faster results)

**[Time Complexity Primer ðŸ”—ðŸ”—](https://dev.to/ankushsinghgandhi/time-complexity-primer-understand-big-o-like-a-kid-with-candies-2ih0)**

---

## âœ… Priority-Based Topic Breakdown

### ðŸ”¥ Tier 1: Must-Do (50-60% Weightage)

> **These are asked in almost every interview** â€“ master them first.

#### ðŸ”¹ 0. Number-Based Problems, String Manipulation, Loops & Basic Data Structures â€” 10%
- Number-based problems (palindrome, prime check, factorial, Armstrong, etc.)  
- String manipulation (reverse, palindrome checks, permutations, compressions, anagrams, substring etc.)  
- Loops, logic, and recursion basics (Fibonacci, pair sums, flattening lists, balanced parentheses)  
- Basic data structures usage (lists, sets, dictionaries, sorting without built-ins, counting elements)  
- Handling exceptions and edge cases  
- Bonus practice challenges (FizzBuzz, grouping characters, advanced string groupings)


#### ðŸ”¹ 1. Arrays & Strings - 15%
- Traversals & updates
- Sorting
  - Quick Sort (O(nlog n))
  - Merge Sort (O(nlog n))
- Sliding Window
  - Subarray problems
  - finding max/min in a window
- Two-pointer technique
  - In-place operations (e.g., removing duplicates)
- Prefix sums
- Binary search and its variations:
  - Classic binary search (O(log n))
  - First/Last occurrence
  - Search in rotated sorted array
  - Binary search on answer (e.g., Painterâ€™s Partition)
- Practice
  - Find kth smallest element in array
  - Implement Kadane's algorithm


#### ðŸ”¹ 2. Linked Lists (Singly Only) - 10%
- Traversal:
  - Iterate through the list, understand the node structure
- Insertion/Deletion
  - At beginning, end, or at a specific position
- Reverse (iterative & recursive)
- Detect cycle (Floydâ€™s Algorithm)
- Practice
  - Merge two sorted lists
  - Find middle of the list
  - Remove N-th node from end
  - Implement a stack using a linked list
  - Find the intersection point of two linked lists
  - Understand only Doubly and Circular

#### ðŸ”¹ 3. Stacks & Queues - 10%
- **Understand concepts** (no need to implement):
  - push/pop
  - enqueue/dequeue
- Practice
  - Valid parentheses
  - Next greater element
  - Monotonic stack / Min stack
  - Implement a stack using arrays (#16)
  - Design a stack that retrieves minimum efficiently
  - Implement a circular queue (#18)
  - Build a queue using stacks (#19)

#### ðŸ”¹ 4. Hashing (HashMap / Set / Dict) - 10%
- **Understand concepts** (no need to implement):
  - Hash function basics
  - Collision handling
- Practice
  - Count frequency of elements
  - Subarray with given sum
  - Find duplicates / first unique
  - Group anagrams
  - Longest substring with no repeats

 
#### ðŸ”¹ 5. Recursion & Backtracking â€” 5%
- Factorial, Fibonacci 
- Subsets, combinations
- Backtracking:
  - N-Queens (basic)
  - Sudoku Solver (optional)
  - Permutations

---

### âš¡ Tier 2: Medium Priority (20â€“25% Weightage)

> Do these next. They're common but not always core.

#### ðŸ”¹ 6. Trees (Binary Trees & BST only) - 15%
- Traversal
  - Inorder, Preorder, Postorder traversal (recursive + iterative)
  - Level order traversal -BFS (Optional)
- Practice
  - Find a node with a given value (especially in BSTs)
  - Height of binary tree
  - Is it a BST?
  - Lowest Common Ancestor (basic version)
  - Compute diameter of a binary tree
  - Convert a binary tree to its mirror 

#### ðŸ”¹ 7. Heaps (Priority Queue) - 5%
- **Understand concepts** (no need to implement):
  - Insertion/Deletion (extract-min/max)
  - Building a Heap
- Min/Max Heap (Optional)
- Practice
  - K largest/smallest elements
  - Sort nearly sorted array


#### ðŸ”¹ 8. Greedy Algorithms - 5%
- Activity selection / Interval scheduling
- Kruskal's algorithm for minimum spanning trees.
- Fractional knapsack
- Minimum number of platforms needed

---

### ðŸ§Š Tier 3: Optional (25-30% Weightage)

> Only if you have time or the company asks for these topics.

#### ðŸ”¹ 9. Graphs - 5-8%
- Traversal
  - Breadth-First Search (BFS)
  - Depth-First Search (DFS)
- Detect cycle 
  - DFS
- Shortest Path
  - Dijkstraâ€™s Algorithm (basic understanding)
- Topological sort
- Bipartite check
- Connected components

#### ðŸ”¹ 10. Dynamic Programming - 15%
- Fibonacci with memoization
- 0/1 Knapsack
- Longest Common Subsequence
- (Optional) Tabulation vs Memoization basics

#### ðŸ”¹ 11. Tries â€” 2â€“3% (Optional
- Implement Trie from scratch
- Insertion/searching
  - For words/prefixes
- Longest prefix matching
- Word dictionary problems
- Using a trie for word suggestions

---

### ðŸŽ¯ Practice Questions After Tier 2 or 3
**[LeetCode 75](https://leetcode.com/studyplan/leetcode-75/)**.
**[LeetCode 150](https://leetcode.com/studyplan/top-interview-150/)**.
#### LeetCode 75 & 150 Easy to Medium Questions
- These curated sets cover core DSA patterns used frequently by top tech companies.
- Focus on problems from these lists after completing Tier 1 to Tier 3 topics for â‚¹10â€“15 LPA roles.
- Solidify your problem-solving skills with easy and medium difficulty questions before moving to advanced topics.

---

### ðŸ§© Tier 4: Advanced & Specialized Topics + Implementation Focus

This tier covers:

> All data structures and algorithms you only *understood* before but didnâ€™t code.
> Advanced concepts and subtopics needed to crack top-tier companies.
> Filling gaps left in previous tiers for a complete mastery.
> Understand & Practice everything that you skipped in previous tiers 

#### ðŸ”¹ 12. Skipped Data Structures from Previous Tiers

- Doubly Linked List and Circular Linked List (previously understood only)  
- Queue using Stacks and Stack using Queues  
- Basic Heap operations (min-heap and max-heap insert, delete)  
- Trie insert, search, and delete operations  
- Disjoint Set Union (Union-Find) with path compression and union by rank  
- HashMap / HashSet from scratch (basic hash function and collision handling)  

#### ðŸ”¹ 13. Advanced Trees & Balanced Trees  
- AVL Trees with all rotations (left, right, left-right, right-left)  
- Basic Red-Black Tree insertions and properties (understand deletions)  
- Segment Trees with build, update, and query operations  
- Fenwick Tree (Binary Indexed Tree) for prefix sums and updates  
- Advanced Trie operations: prefix count, deletion, wildcard search  

#### ðŸ”¹ 14. Advanced Graph Algorithms  
- Strongly Connected Components (Kosarajuâ€™s or Tarjanâ€™s)  
- Minimum Spanning Tree algorithms (Kruskalâ€™s with Union-Find, Primâ€™s)  
- Bellman-Ford algorithm for shortest paths with negative weights  
- Topological Sort (both DFS and Kahnâ€™s algorithm)  
- Basic Network Flow algorithms (Ford-Fulkerson)  
- Cycle detection in directed and undirected graphs  

#### ðŸ”¹ 15. Advanced Dynamic Programming  
- DP on Trees (e.g., subtree sums, independent sets)  
- Bitmask DP for problems like Traveling Salesman or subsets  
- DP optimization techniques (Knuth, Divide & Conquer DP)  
- DP on grids (unique paths with obstacles)  
- Advanced sequence alignment and string DP problems  

#### ðŸ”¹ 16. String Algorithms  
- KMP (Knuth-Morris-Pratt) pattern matching algorithm  
- Rabin-Karp algorithm with rolling hash  
- Z-algorithm for pattern matching and substring problems  
- Basics of Suffix Arrays and Suffix Trees  
- Manacherâ€™s Algorithm for longest palindromic substring in O(n)  

#### ðŸ”¹ 17. Number Theory & Math  
- Modular exponentiation (fast power) and modular inverse  
- Sieve of Eratosthenes for prime generation and prime factorization  
- Euclidean Algorithm for GCD and extended GCD  
- Combinatorial calculations with modular arithmetic  
- Basics of Chinese Remainder Theorem (CRT)  

#### ðŸ”¹ 18. Bit Manipulation  
- Common bit tricks (checking bits, toggling, counting set bits)  
- Brian Kernighanâ€™s algorithm for counting set bits  
- Bitmasking for subset generation and state compression in DP  
- XOR based problems (finding unique elements, parity)  

#### ðŸ”¹ 19. Advanced Data Structures  
- Disjoint Set Union (Union-Find) with path compression and union by rank  
- Skip Lists basics  
- Splay Trees (self-adjusting BSTs)  
- Theory and use cases of Bloom Filters (probabilistic data structures)  

---

### ðŸŽ¯ Practice Questions After Tier 4
#### LeetCode 150 Easy to Hard Questions, Company Specific Questions (Top-Tier Companies)
- After mastering Tier 4, solve these problems to prepare for dream companies like Google, Amazon, Facebook, Microsoft, etc.
- These include harder and more advanced problems, combining multiple concepts.
- Great for building problem-solving stamina and mastering edge cases.

**Pro Tip:**  


### ðŸ§  Final Tips
- Focus on patterns, not just isolated problems.
- Practice LeetCode Easy/Medium problems per category.
- Prioritize Tier 1 & Tier 2 for â‚¹10â€“15 LPA roles
- Tier 3 & 4 for top companies.



---

**You donâ€™t need to know everything â€” just the right things.**
